Implement strStr().

Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.

Example 1:

Input: haystack = "hello", needle = "ll"
Output: 2
Example 2:

Input: haystack = "aaaaa", needle = "bba"
Output: -1

Clarification:

What should we return when needle is an empty string? This is a great question to ask during an interview.

For the purpose of this problem, we will return 0 when needle is an empty string. This is consistent to C's strstr() and Java's indexOf().


Java
some issue in the problems:  --6ms
what's the result when both parameters are both ""; what's the expected result when needle is empty?

1. scan char by char
class Solution {
    public int strStr(String haystack, String needle) {
        //return haystack.indexOf(needle);

        if(haystack==null || haystack.length()==0) return -1;
        if(needle == null || needle.length()==0) return 0;

        for(int i =0; i<=haystack.length()-needle.length();i++){  // error: i<a-b
            int cur=0;
            for(int j=0;j<needle.length(); j++){
                if(haystack.charAt(cur+i)==needle.charAt(j)) cur++;
                else break;
            }
            if (cur== needle.length()) return i;
        }
        return -1;
    }
}

class Main {
    public static void main(String[] args) {

        String a = "a";
        String f = "a";

        Solution test1 = new Solution();
        System.out.print(test1.strStr(a,f));

    }
}
Time Complexity: O(m*n)
Space Complexity: O(1)

2. use while loop, the same algorithm as #1
class Solution {
    public int strStr(String haystack, String needle) {
        int i=0;
        int j=0;
        
        while(i<haystack.length() && j< needle.length()){
            if(haystack.charAt(i)==needle.charAt(j)){
                i++;
                j++;
            }else{
                i = i-j+1;
                j = 0;
            }
        }
        
        if(j== needle.length()) return i-j;
        return -1;
    }
}

3, KMP Substring Search
https://www.youtube.com/watch?v=BXCEFAzhxGY

Time Complexity:
m = len(haystack), n = len(needle)
(1) Built Table: t:O(n), s:O(n)
(2) Match Traversal: t:O(m), s:O(1)
Overall: t: O(n+m) s: O(n)
